import socketio
import json
import redis
import boto3
import jwt  # PyJWT

from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
from starlette.responses import JSONResponse
from robot_manager import robot_connections

# === Redis (ElastiCache Valkey) Setup ===
# üîÅ Replace with your actual ElastiCache Redis endpoint
redis_client = redis.Redis(
    host='robomeans-cache-i8vsax.serverless.cac1.cache.amazonaws.com',  # <<< CHANGE THIS
    port=6379,
    decode_responses=True
)

# === FastAPI and Socket.IO setup ===
sio = socketio.AsyncServer(async_mode='asgi', cors_allowed_origins="*")
app = FastAPI()
socket_app = socketio.ASGIApp(sio, app)

# === Allow CORS for frontend ===
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# === In-memory session tracking for UI sessions ===
active_ui_sessions = {}  # email -> sid

# === Robot state helpers ===
def set_robot_state(robot_id, updates):
    key = f"robot:{robot_id}:state"
    current = redis_client.get(key)
    state = json.loads(current) if current else {}

    # Merge and save
    state.update(updates)
    redis_client.set(key, json.dumps(state))


def get_robot_state(robot_id):
    key = f"robot:{robot_id}:state"
    val = redis_client.get(key)
    return json.loads(val) if val else None


# === WebSocket Events ===

@sio.event
async def connect(sid, environ):
    print(f"‚úÖ WebSocket client connected: {sid}")


@sio.event
async def register_robot(sid, data):
    robot_id = data.get("robot_id")
    if robot_id:
        robot_connections[robot_id] = sid
        set_robot_state(robot_id, {"connection_status": 1})
        print(f"ü§ñ Robot registered: {robot_id} (SID: {sid})")


@sio.event
async def register_ui(sid, data):
    email = data.get("email")
    robot_ids = data.get("robot_ids", [])

    if not email:
        print("‚ùå UI tried to register without email.")
        return

    previous_sid = active_ui_sessions.get(email)
    if previous_sid and previous_sid != sid:
        print(f"‚ö†Ô∏è Duplicate login for {email}. Kicking old session {previous_sid}")
        await sio.emit("force_logout", {}, to=previous_sid)
        await sio.disconnect(previous_sid)

    active_ui_sessions[email] = sid
    print(f"üßë UI registered: {email} (SID: {sid})")

    for rid in robot_ids:
        print(f"üì° UI controls robot: {rid}")


@sio.event
async def command_to_robot(sid, data):
    robot_id = data.get("robot_id")
    command = data.get("command")
    target_sid = robot_connections.get(robot_id)

    if target_sid:
        await sio.emit("command", {"command": command}, to=target_sid)
        print(f"üì§ Sent '{command}' to {robot_id}")
    else:
        print(f"‚ö†Ô∏è Robot {robot_id} not connected")


@sio.event
async def status_update(sid, data):
    robot_id = data.get("robot_id")
    if not robot_id:
        return

    print(f"üì• Status from {robot_id}: {data}")
    await sio.emit("status", data)

    updates = {}

    if "activation_status" in data:
        updates["activation_status"] = data["activation_status"]
        updates["operating_mode"] = 1
        updates["homing_status"] = 1
        updates["mission_status"] = 0
        updates["pose"] = {"x": 0, "y": 0, "theta": 0}

    if "operating_mode" in data:
        updates["operating_mode"] = data["operating_mode"]

    if "homing_status" in data:
        updates["homing_status"] = data["homing_status"]

    if "mission_status" in data:
        updates["mission_status"] = data["mission_status"]

    if "pose" in data:
        updates["pose"] = data["pose"]

    if "battery" in data:
        updates["battery"] = data["battery"]

    set_robot_state(robot_id, updates)


@sio.event
async def disconnect(sid):
    for rid, rsid in list(robot_connections.items()):
        if rsid == sid:
            del robot_connections[rid]
            print(f"‚ùå Robot disconnected: {rid}")
            set_robot_state(rid, {"connection_status": 0})

    for email, esid in list(active_ui_sessions.items()):
        if esid == sid:
            del active_ui_sessions[email]
            print(f"‚ùå UI session disconnected for {email}")


# === REST API ===

@app.get("/api/myrobots")
async def get_my_robots(request: Request):
    try:
        auth_header = request.headers.get("authorization")
        if not auth_header or not auth_header.startswith("Bearer "):
            raise ValueError("Missing or invalid Authorization header")
        token = auth_header.split(" ")[1]

        decoded = jwt.decode(token, options={"verify_signature": False})
        user_email = decoded.get("email")
        if not user_email:
            raise ValueError("Email not found in token")

        dynamodb = boto3.client("dynamodb", region_name="ca-central-1")
        response = dynamodb.query(
            TableName="UserRobotMapping",
            KeyConditionExpression="email = :e",
            ExpressionAttributeValues={":e": {"S": user_email}},
        )

        items = response.get("Items", [])
        robots = [
            {
                "robot_id": item["robot_id"]["S"],
                "ui_type": item.get("ui_type", {}).get("S", "default")
            }
            for item in items
        ]

        return JSONResponse(content={"robots": robots})

    except Exception as e:
        print("üö® Error in /api/myrobots:", e)
        return JSONResponse(status_code=401, content={"error": str(e)})


@app.get("/api/robot_state/{robot_id}")
async def get_robot_state_api(robot_id: str):
    state = get_robot_state(robot_id)
    if state:
        return JSONResponse(content=state)
    else:
        return JSONResponse(status_code=404, content={"error": "Robot not found"})
